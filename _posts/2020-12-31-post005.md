---
layout: post
title: "Kadane's Algorithm to Solve the Maximum Sum Subarray Problem"
category: Project Euler
tags: [largest contiguous subarray, kadane's algorithm, python, project euler]
date: 2020-12-31

---
#### PROBLEM

[Problem](https://projecteuler.net/problem=149)

Given a matrix with entries generated by a pseudorandom generator function, find the subarray made of contiguous entries with  maximum sum along any direction.

---

One way to solve this problem is to make 1D arrays out of each horizontal row, vertical column, left diagonal elements and right diagonal elements.

Then for each of these arrays we find the largest subarray with maximal sum. And finally the maximum among these gives the solution.

---
**STEP 1**

This step takes a matrix and generates all possible 1D arrays along the row, column and diagonals.

Below is a partial python snippet to do this.

```
def f(g):
	gt = list(zip(*g))
	for i in range(SIZE):
			# left to right top half
			d1= []
			# left to right bottom half
			d2 = []
			# right to left top half
			d3 = []
			# right to left bottom half
			d4 = []
			# row
			d5 = g[i]
			# column
			d6 = gt[i]

			for x in range(0,SIZE-i):
				d1.append(g[x][x+i])
				d2.append(g[x+i][x])
				d3.append(g[x][SIZE-x-i-1])
				d4.append(g[x+i][SIZE-x-1])


```

Consider the 4 by 4 2d array(list) g below along with row and column numbers.

|r/c|0|1|2|3|
:--|:--|:--|:--|:--|
|0|−2|5|3|2|
|1|9|−6|5|1|
|2|3|2|7|3|
|3|−1|8|−4|8|

d5 gives us the rows like [-2,5,3,2], [9,-6,5,1] etc

d6 gives us the columns like [-2,9,3,-1], [5,-6,2,8] etc

d1 gives the top half of left to right diagonal like [2], [3,1], [5,5,3]

d2 gives the bottom half of left to right diagonal like [-1], [3,8], [9,2,-4]

d3 gives the top half of right to left diagonal like [-2], [5,9], [3,-6, 3]

d4 gives the bottom half of right to left diagonal like [8], [3,-4], [1,7,8]


---

**STEP 2**

The largest subarray sum problem can be stated formally as follows

Given an array of integers , $A = [a_0,a_1,....a_{n-1}]$ , find a subarray $A[a_l,....a_r]$ such that $\sum_{i=l}^{r} A[i]$ is maximum

**Example**

The maximum sum subarray in A = [-2, 4, 2, -3, 1] is a = [4,2] with sum = 6

|index|0|1|2|3|4|
|:---|:---|:---|:---|:---|:---|
|elements|-2|4|2|-3|1|

One way to solve this problem is through brute force. Find every possible subarray and the corresponding sum. Find the maximum among these.

We will have 15 possible subarrays for this problem listed as below.

|start index|0|1|2|3|4|
|:---|:---|:---|:---|:---|:---|
|0|-2|4|2|-3|1|
|0|-2|4|2|-3||
|0|-2|4|2|||
|0|-2|4|||
|0|-2|||||
|1|4|2|-3|1|
|1|4|2|-3||
|1|4|2|||
|1|4|||
|2|2|-3|1|
|2|2|-3|
|2|2|
|3|-3|1|
|3|-3|
|4|1|

As we can see, starting from index 0 we have 5 possible subarrays, from index 1 there are 4 possible subarrays and so on.

For an array of length n, there are n*(n+1)/2 possibilities.

So the brute force solution can be solved in $O(n^2)$ time.

---

[Jay Kadane](https://en.wikipedia.org/wiki/Maximum_subarray_problem) proposed an algorithm to solve the problem in $O(n)$ time.

Going back to the example, Kadane's algorithm uses the idea of a local and global maximum.

Local maximum is the maximum for all subarrays formed with element at index i as the last element.

|start index|0|1|2|3|4|
|:---|:---|:---|:---|:---|:---|
|elements|-2|4|2|-3|1|

If we list all subarrays with index 2 as the last element, we get

|0|1|2|3|4|sum|
|:---|:---|:---|:---|:---|:---|
|-2|4|2|||4|
|4|2||||6|
|2|||||2|

So the local maximum for index 2 is 6 corresponding to subarray [4,2]

Below is the table for local maximums for all indices

|ending index|0|1|2|3|4|local max|
|:---|:---|:---|:---|:---|:---|:---|
|0|-2|||||2|
|1||4||||4|
|2||4|2|||6|
|3||4|2|-3||3|
|4||4|2|-3|1|4|

A look at the table above tells us 6 is the global maximum and the corresponding subarray [4,2] is the longest subarray.

The way Kadane's algorithm implemented in Python is as below.

```
def kadane(x):
    max_local = x[0]
    max_global = x[0]
    for i in range(1,len(x)):
        max_local = max(x[i],max_local+x[i])
        if max_local > max_global:
            max_global = max_local
    return max_global
```

---
**EXAMPLE 1**

Consider another example for a code walkthrough.

|index|0|1|2|3|4|5|
|:---|:---|:---|:---|:---|:---|
|elements|3|-1|5|9|-7|2|

max_local = x[0] = 3
max_global = x[0] = 3

**ITERATIONS**

**i = 1**

max_local = max(x[1],max_local+x[1]) = max(-1,2) = 2

max_local < max_global

So max_global = 3

**i = 2**

max_local = max(x[2],max_local+x[2]) = max(5,7) = 7

max_local > max_global

So max_global = 7

**i = 3**

max_local = max(x[3],max_local+x[3]) = max(9,16) = 16

max_local > max_global

So max_global = 16

**i = 4**

max_local = max(x[4],max_local+x[4]) = max(-7,9) = 9

max_local < max_global

So max_global = 16

**i = 5**

max_local = max(x[5],max_local+x[5]) = max(2,11) = 11

max_local < max_global

So max_global = 16

This gives a global maximum of 16 corresponding to the subarray 3,-1,5,9

---

**EXAMPLE 2**

max_local = x[0] = 3
max_global = x[0] = 3

|index|0|1|2|3|4|5|
|:---|:---|:---|:---|:---|:---|
|elements|3|-4|1|5|-6|2|

**ITERATIONS**

**i = 1**

max_local = max(x[1],max_local+x[1]) = max(-4,-1) = -1

max_local < max_global

So max_global = 3

**i = 2**

max_local = max(x[2],max_local+x[2]) = max(1,0) = 1

max_local < max_global

So max_global = 3

**i = 3**
max_local = max(x[3],max_local+x[3]) = max(5,6) = 6
max_local > max_global

So max_global = 6

**i = 4**

max_local = max(x[4],max_local+x[4]) = max(-6,0) = 0

max_local < max_global

So max_global = 6

**i = 5**

max_local = max(x[5],max_local+x[5]) = max(2,2) = 2

max_local < max_global

So max_global = 6

This gives a global maximum of 6 corresponding to the subarray [1,5]

---

**STEP 3**

All that's left to do is to run the 1D arrays obtained from STEP 1 and run the Kadane's algorithm on each of them and get the maximum sum for each list. The maximum of these maximums gives the final solution.

---
