<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

	<title>Blog</title>
	<link href="http://amsykal.github.io/blog/atom.xml" rel="self"/>
	<link href="http://amsykal.github.io/blog"/>
	<updated>2021-01-14T20:57:00+05:30</updated>
	<id>http://amsykal.github.io/blog</id>
	<author>
		<name>Lakshmi</name>
		<email>a.lakshmi.s@gmail.com</email>
	</author>

	
		<entry>
			<title>Art with Code: Lines in a Recursive Grid</title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/14/post014.html"/>
			<updated>2021-01-14T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/14/post014</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Stephen Hawking: ‘To understand recursion, one must first understand recursion.’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/014a.png&quot; /&gt;
&lt;img src=&quot;/images/014b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014h.png&quot; /&gt;
&lt;img src=&quot;/images/014i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014k.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014l.png&quot; /&gt;
&lt;img src=&quot;/images/014m.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014n.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/014o.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// code snippet referenced: https://editor.p5js.org/runemadsen/sketches/rkbBsG_1z
// we use recursive division to split a rectangle
// eachr rectangle is then filled with noisy lines
// the noisy lines are drawn vertically when height &amp;gt; width
// horizontally when width &amp;gt; height
// randomize color choice
// variations include change in rectangle size and choice of noise level

// margin
let margin = 0

// smallest permitted width or height
//change this for variations
let s = 20;
// to store palette
let colors = [];
// simplex noise
let simplexNoise;



function setup() {
  createCanvas(600, 600);
  simplexNoise = new OpenSimplexNoise(Date.now());
  colors = [color(208, 0, 0),color(255, 186, 8),
            color(221, 225, 230),color(63, 136, 197)];
}

function draw(){
  noLoop();
  drawRect(margin,margin, width - 2*margin, height - 2*margin);
}

// recursive division of rectangle
function drawRect(x, y, w, h)
{

  render(x,y,w,h);
  // then figure out if we need to draw another
  let splitWidth = random(1) &amp;gt; 0.5;
  let splitWhere = random(0.3, 0.8);

  // if we're splitting the width
  if(splitWidth &amp;amp;&amp;amp; w &amp;gt; s)
  {
    drawRect(x, y, w * splitWhere, h);
    drawRect(x + (w * splitWhere), y, w * (1 - splitWhere), h);

  }
  // else if we're splitting the height
  else if(h &amp;gt; s)
  {
    drawRect(x, y, w, h * splitWhere);
    drawRect(x, y + (h * splitWhere), w, h * (1 - splitWhere));
  }
}

// final sketch to fill each rectangle with noisy lines
function render(x,y,w,h){

  push();
  translate(x,y);

  // clear previous drawings
  let cl = random(colors);
  fill( 23, 28, 51);
  stroke(0);
  strokeWeight(8);
  w = 2*w;
  h = 2*h;
  rect(0,0,w,h);

  strokeWeight(2);
  let sl = random(colors);
  sl.setAlpha(255);
  stroke(sl);

  // some sketches have both horizontal and vertical lines

  // if width greater, fill horizontally
  if(w &amp;gt;= h){
    let sh = h/10;
    for(let y = 0; y &amp;lt; h; y+= sh){
      // draw new stuff

      beginShape();
      for(let x = 0; x &amp;lt; w; x++){
        // change .1 to other values for variations
        let z = sh*simplexNoise.noise2D(.1*x,.1*y);
        //fill(random(colors));
        vertex(x, y+z);
      }
      endShape();
    }
  }
  // if height greater, fill vertically
  else{
    let sw = w/10;
    for(let x = 0; x &amp;lt; w; x+=sw){
      beginShape();
      for(let y = 0; y &amp;lt; h; y++){
        // change .1 to other values for variations
        let z = sw*simplexNoise.noise2D(.1*y,.1*x);
        vertex(x+z, y);
      }
      endShape();
    }
  }
  pop();

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;This series is a combination of &lt;a href=&quot;https://amsykal.github.io/art with code/2021/01/10/post012.html&quot;&gt;the series using recursive division&lt;/a&gt; and &lt;a href=&quot;https://amsykal.github.io/art with code/2021/01/03/post008.html&quot;&gt;the series implementing noisy lines in a grid&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In each rectangle obtained by recursive division, we draw simplex noise based lines.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/joshforisha/open-simplex-noise-js&quot;&gt;Open Simplex Noise Package&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://weber.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf&quot;&gt;Simplex Noise Demystified&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Lv9gyZZJPE0&quot;&gt;What is OpenSimplex Noise? - Coding Train&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mzucker.github.io/html/perlin-noise-math-faq.html&quot;&gt;Perlin Noise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/&quot;&gt;Etienne Jacob&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Art with Code: Hexagons</title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/11/post013.html"/>
			<updated>2021-01-11T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/11/post013</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Johannes Kepler: ‘There must be some definite cause why, whenever snow begins to fall, its initial formations invariably display the shape of a six-cornered starlet. For if it happens by chance, why do they not fall just as well with five corners or with seven? Why always with six?.’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/013b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013h.png&quot; /&gt;
&lt;img src=&quot;/images/013i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/013k.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// basic rectangle division
// repeated division of rectangle into smaller rectangles
// concentric hexagons in each rectangle

// smallest permitted width or height
// change s for variations
let s = 100;
// to store palette
let colors = [];
let margin = 0

function setup() {
  createCanvas(600, 600);
  colors = [color(31, 32, 65),color(75, 63, 114),
            color(255, 200, 87),color(17, 157, 164),color( 25, 100, 126)]
}

function draw(){
  background(255);
  noLoop();
  push();
  // call recursive div algorithm
  drawRect(margin,margin, width - 2*margin, height - 2*margin);
  pop();

}

// recursive division of rectangle
function drawRect(x, y, w, h)
{
  // draw the hexagons within the rectangle
  render(x,y,w,h);
  // then figure out if we need to draw another
  let splitWidth = random(1) &amp;gt; 0.5;
  let splitWhere = random(0.3, 0.8);

  // if we're splitting the width
  if(splitWidth &amp;amp;&amp;amp; w &amp;gt; s)
  {
    drawRect(x, y, w * splitWhere, h);
    drawRect(x + (w * splitWhere), y, w * (1 - splitWhere), h);

  }
  // else if we're splitting the height
  else if(h &amp;gt; s)
  {
    drawRect(x, y, w, h * splitWhere);
    drawRect(x, y + (h * splitWhere), w, h * (1 - splitWhere));
  }
}



// final sketch to draw rectangles
function render(x,y,w,h){

  push();
  // move center to x,y
  translate(x,y);
  strokeWeight(4);
  let fl = random(colors);
  fl.setAlpha(100);
  fill(fl);
  // variation stroke black, white
  stroke(5);
  rect(0,0, w, h);
  strokeWeight(2);
  let cl = random(colors);
  cl.setAlpha(120);
  // variation stroke black, white, colors
  stroke(5);
  //stroke(random(colors));
  // remove fill for black and white variation
  fill(cl);

  // set n to 6 to draw hexagons
  let n = 6;

  // variation
  // this decides orientation of the hexagon
  //fixed angle 0 , PI/6
  //let a = 0 ;
  let a = PI/6;
  //let a = random(2*PI);

  // variation - concentric hexagons
  cPolygon(w/2,h/2,min(w/2,h/2),n,a);
  pop();

}

// simple function to draw polygon of any number of sides
// in this case hexagons
// x, y - center
// radius - distance between center and vertex of hexagon
// angle - orientation of hexagon
function polygon(x, y, radius, sides = 3, angle = 0) {

  push();
  translate(x,y);
  beginShape();
  for (let i = 0; i &amp;lt; sides; i+=1) {
    let a = angle + TWO_PI * (i / sides);
    let sx = cos(a) * radius;
    let sy = sin(a) * radius;
    vertex(sx, sy);
  }
  endShape(CLOSE);
  pop();

}

// simple function to draw concentric polygons of any number of sides
function cPolygon(x, y, radius, sides = 3, angle = 0,offset = 0) {
  for(let i = radius; i &amp;gt; 4; i-=10){
    polygon(x,y,i,sides,angle);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;This series builds on top of the &lt;a href=&quot;https://amsykal.github.io/project%20euler/2021/01/10/post012.html&quot;&gt;previous series using recursive division&lt;/a&gt;.
In each rectangle, we render concentric regular hexagons.&lt;/p&gt;

&lt;p&gt;Even a casual observer of nature is unlikely to miss the recurring presence of hexagons in everything from beehives to Devils Postpile.&lt;/p&gt;

&lt;p&gt;Kepler’s essay on The Six Cornered Snowflake , A New Year’s Gift is not only a good start for us to start wondering about “why hexagons” but also a beautiful exposition on the workings of his mind, the brilliance,genius and playfulness of his thought process.What is fascinating is that such a seemingly simple question remained unanswered for nearly 300 years after Kepler first made an attempt.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://larouchepac.com/snowflake&quot;&gt;Six Cornered Snowflake - By Johannes Kepler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bbc.co.uk/programmes/w3csy5b7&quot;&gt;Kepler’s Snowflake, BBC Science Stories&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.scientificamerican.com/article/why-are-snowflakes-symmet/&quot;&gt;Why Are Snowflakes Symmetrical&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Art with Code: Rectangles</title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/10/post012.html"/>
			<updated>2021-01-10T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/10/post012</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Piet Mondrian: ‘Art is higher than reality and has no direct relation to reality. To approach the spiritual in art, one will make as little use as possible of reality, because reality is opposed to the spiritual. We find ourselves in the presence of an abstract art. Art should be above reality, otherwise it would have no value for man.’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/012a.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/012h.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// basic rectangle division
// repeated division of rectangle into smaller rectangles
// this sketch has code for simple division

// smallest permitted width or height
// change s for variations
let s = 15;
// margin (border)
let margin = 10;
// to store palette
let colors = [];


function setup() {
  createCanvas(600, 600);
  background(255)
  colors = [color(208, 0, 0),color(255, 186, 8),
            color(221, 225, 230),color(63, 136, 197),
            color(0,0,0)];
}

function draw(){
  noLoop();
  // call recursive div algorithm
  drawRect(margin,margin,width-2*margin,height-2*margin);
}

// recursive division of rectangle
function drawRect(x,y,w,h)
{
  // draw a rectangle of width w and height h at (x,y)
  render(x,y,w,h);

  // then figure out if we need to draw another
  let splitWidth = random(1) &amp;gt; 0.5;
  let splitWhere = random(0.3, 0.8);

  // if we're splitting the width
  if(splitWidth &amp;amp;&amp;amp; w &amp;gt; s)
  {
    drawRect(x, y, w * splitWhere, h);
    drawRect(x + (w * splitWhere), y, w * (1 - splitWhere), h);
  }
  // else if we're splitting the height
  else if(h &amp;gt; s)
  {
    drawRect(x, y, w, h * splitWhere);
    drawRect(x, y + (h * splitWhere), w, h * (1 - splitWhere));
  }
}

// final sketch to draw rectangles
function render(x,y,w,h){
  push();
  // move center to x,y i.e make current rectangle the reference
  translate(x,y);
  // colors etc
  let fl = random(colors);
  fill(fl);
  stroke(0);
  // change depending on size of rectangle, greater thickness for larger rects
  strokeWeight(1);
  rect(0,0, w, h);
  pop();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;This is a simple series of sketches.&lt;/p&gt;

&lt;p&gt;We draw rectangles recursively,deciding at every iteration of the recursion whether to divide vertically or horizontally.&lt;/p&gt;

&lt;p&gt;Variations are the result of randomisation of division,changes in size of smallest possible rectangle and choice of colours.&lt;/p&gt;

&lt;p&gt;Th choice of color palette in this  series is influenced in part by Piet Mondrian’s Composition II with Red, Blue and Yellow.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.singulart.com/en/2020/02/20/composition-ii-with-red-blue-and-yellow-1930-piet-mondrian-and-neo-plasticism/&quot;&gt;Piet Mondrian and De Stijl Movement&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Art with Code: Criss Cross </title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/08/post011.html"/>
			<updated>2021-01-08T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/08/post011</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Sol LeWitt: ‘You shouldn’t be a prisoner of your own ideas.’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/011a.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011h.png&quot; /&gt;
&lt;img src=&quot;/images/011i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011k.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011l.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011m.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011n.png&quot; /&gt;
&lt;img src=&quot;/images/011o.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/011p.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// grid of cells
// in each cell noise lines are drawn
// lines are drawn symmetrically in 2 directions
// circle used as reference for endpoints of lines
// for double/triple line effect noise level is varied and
// lines are redrawn
// randomness increased from cell to cell

let cl,simplexNoise;
let s,seed;
let k;

// simple function to draw lines in a polygon
function polygon(x, y, radius, start, end) {
  // variations by changing a+= from PI/2 to PI/20
  beginShape();
  for (let a = start; a &amp;lt; end; a+= PI/8) {

    let sx = cos(a) * radius;
    let sy = sin(a) * radius;

    // drawing the lines
    // changing height increases randomness
    let height = 5;
    beginShape();
    for(let x = sx; x &amp;lt; -sx; x++){
      let sn = simplexNoise.noise2D(seed+k*x,seed+k*sy);
      let y = sy + height*sn;
      vertex(x,y);
    }
    endShape();
    // comment everything below if you want only one line

    // for double lines
    height = 10;
    beginShape();
    for(let x = sx; x &amp;lt; -sx; x++){
      let sn = simplexNoise.noise2D(seed+k*x,seed+k*sy);
      let y = sy + height*sn;
      vertex(x,y);
    }
    endShape();

    // 3 lines
    height = 20;
    beginShape();
    for(let x = sx; x &amp;lt; -sx; x++){
      let sn = simplexNoise.noise2D(seed+k*x,seed+k*sy);
      let y = sy + height*sn;
      vertex(x,y);
    }
    endShape();
  }

  // increase noise for each cell by this amount
  // this increment can be changed for variations
  k += 0.005;
  endShape();

}

function setup(){
  createCanvas(600,600);
  background(230, 230, 230);
  // set up colors
  cl = color(12, 32, 32,250);
  strokeWeight(2);
  stroke(cl);
  noFill();

  simplexNoise = new OpenSimplexNoise(Date.now());
  // change seed for each render
  seed = 1000;
  k = 0;
}

function draw(){
  noLoop();
  makeGrid();
}

function makeGrid(){
  // cell size - change for variations
  s = 100;
  // get number of rows and cols
  let rows = height/s;
  let cols = width/s;
  for(let i = 1; i &amp;lt; cols-1; i++){
    for(let j = 1; j &amp;lt; rows-1; j++){
      let x = i*s;
      let y = j*s;

      // set 1
      // change PI/2 to PI/4, PI/6 etc for variations
      // move origin to centre of cell
      push();
      translate(x+s/2,y+s/2);
      rotate(PI/3);
      polygon(0,0, 0.45*s, 0.5*PI,1.5*PI) ;
      pop();

      // set 2
      // repeat symmetrically
      push();
      translate(x+s/2,y+s/2);
      rotate(-PI/3);
      polygon(0,0, 0.45*s, 0.5*PI,1.5*PI) ;
      pop();
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;This set features criss crossed lines.&lt;/p&gt;

&lt;p&gt;The lines are drawn using 2D open simplex noise.&lt;/p&gt;

&lt;p&gt;The canvas is divided into a grid with cells.makeGrid() handles this.&lt;/p&gt;

&lt;p&gt;For each cell we call the polygon function twice.
Polygon function draws lines symmetrically in 2 directions
A circle is used as a reference for endpoints of the lines.&lt;/p&gt;

&lt;p&gt;For details about how variations are obtained, refer to the comments in the code.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/joshforisha/open-simplex-noise-js&quot;&gt;Open Simplex Noise Package&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://weber.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf&quot;&gt;Simplex Noise Demystified&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Lv9gyZZJPE0&quot;&gt;What is OpenSimplex Noise? - Coding Train&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mzucker.github.io/html/perlin-noise-math-faq.html&quot;&gt;Perlin Noise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/&quot;&gt;Etienne Jacob&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>An Expected-Value Problem</title>
			<link href="http://amsykal.github.io/project%20euler/2021/01/06/post010.html"/>
			<updated>2021-01-06T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/project%20euler/2021/01/06/post010</id>
			<content type="html">&lt;h4 id=&quot;problem&quot;&gt;PROBLEM&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=151&quot;&gt;Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A printing shop runs 16 batches (jobs) every week and each batch requires a sheet of special colour-proofing paper of size A5.&lt;/p&gt;

&lt;p&gt;Every Monday morning, the supervisor opens a new envelope, containing a large sheet of the special paper with size A1.&lt;/p&gt;

&lt;p&gt;The supervisor proceeds to cut it in half, thus getting two sheets of size A2. Then one of the sheets is cut in half to get two sheets of size A3 and so on until an A5-size sheet is obtained, which is needed for the first batch of the week.&lt;/p&gt;

&lt;p&gt;All the unused sheets are placed back in the envelope.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e010.png&quot; width=&quot;150&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At the beginning of each subsequent batch, the supervisor takes from the envelope one sheet of paper at random. If it is of size A5, then it is used. If it is larger, then the ‘cut-in-half’ procedure is repeated until an A5-size sheet is obtained, and any remaining sheets are always placed back in the envelope.&lt;/p&gt;

&lt;p&gt;Excluding the first and last batch of the week, find the expected number of times (during each week) that the supervisor finds a single sheet of paper in the envelope.&lt;/p&gt;

&lt;p&gt;Give your answer rounded to six decimal places using the format x.xxxxxx .&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;We represent the envelope as a list a&lt;/p&gt;

&lt;p&gt;a[0] represents number of A1 sheets&lt;/p&gt;

&lt;p&gt;a[1] represents number of A2 sheets&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;a[4] represents number of A5 sheets&lt;/p&gt;

&lt;p&gt;Initially we have a = [1,0,0,0,0]&lt;/p&gt;

&lt;p&gt;In the beginning of week 1 , we have only once choice - cut the first A1 sheet.&lt;/p&gt;

&lt;p&gt;Once this is done we have&lt;/p&gt;

&lt;p&gt;a = [0,1,1,1,1]&lt;/p&gt;

&lt;p&gt;Note that although we get 2 A5 sheets, one gets used.&lt;/p&gt;

&lt;p&gt;Now we have a choice of picking A2,A3,A4,A5
Let’s say we pick A2 , once done with the cutting we will have&lt;/p&gt;

&lt;p&gt;a = [0,0,2,2,2]&lt;/p&gt;

&lt;p&gt;So went from [1,0,0,0,0] –&amp;gt; [0,1,1,1,1] –&amp;gt; [0,0,2,2,2]&lt;/p&gt;

&lt;p&gt;Again, we have a choice of picking A3,A4 or A5, if we pick A3 we end up with&lt;/p&gt;

&lt;p&gt;a = [0,0,1,3,3]&lt;/p&gt;

&lt;p&gt;It’s easy to see we will end up with many possible paths.&lt;/p&gt;

&lt;p&gt;Recursive solution seems like a good bet.&lt;/p&gt;

&lt;p&gt;Below is a partial Python snippet showing how this can be done.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def f(x,b):

    # intially number of times
    # the supervisor finds a single sheet of paper in the envelope.
    # is 0
    ans = 0
    # if all sheets add up to 1
    # ans increase by 1
    if sum(x) == 1:
        ans += 1
    # we are done with the last batch
    if b == 0:
        return ans
    # pick a sheet
    for i in range(5):
        if x[i] != 0:
            # probability of picking this sheet
            p = x[i]/sum(x)
            # update expected value of finding a single sheet
            ans += p*f(cutsheet(x,i),b-1)

    return ans


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cutsheet is a function that updates the number of sheets once we are done with cutting and b is the number of batches.&lt;/p&gt;
</content>
		</entry>
	
		<entry>
			<title>Art with Code: Noisy Lines In Circles</title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/04/post009.html"/>
			<updated>2021-01-04T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/04/post009</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Sol LeWitt: ‘The idea becomes a machine that makes the art.’’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/009a.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009h.png&quot; /&gt;
&lt;img src=&quot;/images/009i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/009j.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// grid based design
// every cell in grid is filled circles
// these circles in turn are made of horizontal noisy lines
// noise is simplex based
// for variations
// color and noise level chosen randomly
// cell size s is varied
// spacing between lines is also changed

let cl,simplexNoise;
let s,seed;
let k;
let colors = [];


function setup(){
  createCanvas(600,600);
  background(25, 3, 30);
  // palette
  colors =[color( 217, 229, 214),color(0, 167, 225),color(237, 222, 164),
          color(247, 160, 114),color(255, 155, 66)];
  simplexNoise = new OpenSimplexNoise(Date.now());
  seed = 1000;
  // noise factor to be incremented for each cell
  k = 0;
}

function draw(){
  noLoop();
  makeGrid();
}

function makeGrid(){
  // cell size
  s = 60;
  let rows = height/s;
  let cols = width/s;
  for(let i = 1; i &amp;lt; cols-1; i++){
    for(let j = 1; j &amp;lt; rows-1; j++){
      let x = i*s;
      let y = j*s;
      push();
      translate(x,y);
      render();
      // change this to experiment like .001,.01, etc
      k += 0.005;
      pop();
    }
  }
}

function render(){
  noFill();
  cl = random(colors);
  cl.setAlpha(100);
  stroke(cl);
  // call to draw a circle of noisy lines
  polygon(s/2,s/2,0.4*s, 0.5*PI,1.5*PI) ;
}

// simple function to draw polygon of any number of sides
// in this sketch we use it to draw a circle
function polygon(x, y, radius, start, end) {
  push();
  translate(x,y);
  for (let a = start; a &amp;lt; end; a+= PI/150) {

    // gives a point on the circumference of the circle
    // PI/150 decides spacing between lines, change this to inc/dec the spacing
    let sx = cos(a) * radius;
    let sy = sin(a) * radius;

    // change height to experiment
    let height = 2;
    beginShape();
    for(let x = sx; x &amp;lt; -sx; x++){
      let sn = simplexNoise.noise2D(seed+k*x,seed+k*sy);
      let y = sy + height*sn;
      vertex(x,y);
    }
    endShape();
  }
  pop();
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;This series follows the same procedure as the &lt;a href=&quot;https://amsykal.github.io/art%20with%20code/2021/01/03/post008.html&quot;&gt;previous series&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One minor modification is that we change not only the seed but also the value of k while moving from one cell to next thereby making the lines noisier as we move from first cell to the last.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/joshforisha/open-simplex-noise-js&quot;&gt;Open Simplex Noise Package&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://weber.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf&quot;&gt;Simplex Noise Demystified&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Lv9gyZZJPE0&quot;&gt;What is OpenSimplex Noise? - Coding Train&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mzucker.github.io/html/perlin-noise-math-faq.html&quot;&gt;Perlin Noise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/&quot;&gt;Etienne Jacob&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Art with Code: Noisy Lines</title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/03/post008.html"/>
			<updated>2021-01-03T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/03/post008</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Vera Molnár: ‘I have no regrets. My life is squares, triangles, lines’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/005a.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005h.png&quot; /&gt;
&lt;img src=&quot;/images/005i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005k.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005l.png&quot; /&gt;
&lt;img src=&quot;/images/005m.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005n.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/005o.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// grid based design
// every cell in grid is filled with horizontal noisy lines
// noise is simplex based
// for variations
// color chosen randomly from a fixed palette
// cell size s is varied
// gap g between lines in each cell is varied
// for changing level of noise scaling factor sc and k is varied

let s;
let colors = [];
let simplexNoise;
let seed;

function setup(){
  createCanvas(600,600);
  background(0);
  // palette
  colors = [color(255, 255, 252),color(190, 183, 164,color(255, 127, 17)),
            color(255, 63, 0),color(243, 198, 119)]
  // create noise object
  simplexNoise = new OpenSimplexNoise(Date.now());
  // set cell size
  // change to 150, 200 for different sizes
  s = 100;
  // seed for noise which we will vary for very cell
  seed = 0;
}

function draw(){
  noLoop();
  makegrid();
}

function makegrid(){
  // set number of rows and columns
  let rows = height/s;
  let cols = width/s;

  // make a grid of cells
  for(let i = 0; i &amp;lt; rows-1; i++){
    for(let j = 0; j &amp;lt; cols-1; j++){
      let x = j*s+s/2;
      let y = i*s+s/2;
      push();
      translate(x,y);
      // in each cell draw horizontal noisy lines
      // changing the gap between the lines, the noise input etc
      // gives variations
      render();
      pop();
    }
  }
}

function render(){
  // gap between lines in each cell
  // change g to 2,3,4 etc
  let g = 1;
  // margin to be left for each cell on all sides
  let m = 10;
  // change seed for every cell to get different patterns
  seed += 1000;
  // change color to black and white for variations
  let rl = random(colors);

  strokeWeight(1);
  rl.setAlpha(250);
  stroke(rl);
  noFill();

  // drawing the lines
  for(let i = m; i &amp;lt;= s-m; i+=g){

    beginShape();
    for(let x = m; x &amp;lt;= s-m; x+=g){
      // try changing k to .01 to 0.001,0.1 etc
      // change sc to 1,5,10,etc
      let sc = 15;
      let k = 0.05
      let y = i+sc*simplexNoise.noise2D(seed+k*x,seed+k*i);
      y = i + sc*simplexNoise.noise2D(2*seed+k*x,2*seed+k*i);
      vertex(x,y);
    }
    endShape();
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;This series uses Open Simplex Noise to draw lines.&lt;/p&gt;

&lt;p&gt;The idea is to first make a grid of cells.The function makegrid() handles this bit. And for each cell makegrid() calls render().
render() then fills each cell with horizontal lines.
The lines are drawn using 2D Open Simplex Noise as so&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// drawing the lines
for(let i = m; i &amp;lt;= s-m; i+=g){

  beginShape();
  for(let x = m; x &amp;lt;= s-m; x+=g){
    // try changing k to .01 to 0.001,0.1 etc
    // change sc to 1,5,10,etc
    let sc = 15;
    let k = 0.05
    let y = i+sc*simplexNoise.noise2D(seed+k*x,seed+k*i);
    vertex(x,y);
  }
  endShape();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We run 2 loops one to move down the vertical axis(i) and one to move along the horizontal axis(x)&lt;/p&gt;

&lt;p&gt;If we were to change vertex(x,y) to vertex(x,i) we would simply get evenly spaced straight horizontal lines. What we do with the simplex noise is to shift i by just a bit at each point.This particular implementation uses the 2D version which takes 2 inputs.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let y = i+sc*simplexNoise.noise2D(seed+k*x,seed+k*i);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;i and x are the original points in this particular cell.
Note that we shift the origin to each top left corner of cell and render() draws wrt this shifted origin.&lt;/p&gt;

&lt;p&gt;k decides smoothness of the line.Smaller the value smoother the line, higher the value, jerkier the line.&lt;/p&gt;

&lt;p&gt;sc is just a scaling factor.&lt;/p&gt;

&lt;p&gt;seed - simplex noise is pseudo random in nature, i.e for a given set of input values , it always returns the same value.
In order to have different lines in different cells we change the seed value.If we do not change seed, every cell will have similar looking lines.&lt;/p&gt;

&lt;p&gt;Perlin noise will work just fine for this series.&lt;/p&gt;

&lt;p&gt;Etienne Jacob offers a gentle and more thorough look at the ways in which we can use noise &lt;a href=&quot;https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Code has comments on where randomness has been implemented to generate the variations.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/joshforisha/open-simplex-noise-js&quot;&gt;Open Simplex Noise Package&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://weber.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf&quot;&gt;Simplex Noise Demystified&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Lv9gyZZJPE0&quot;&gt;What is OpenSimplex Noise? - Coding Train&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mzucker.github.io/html/perlin-noise-math-faq.html&quot;&gt;Perlin Noise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/&quot;&gt;Etienne Jacob&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Minimum Sum Sub-Triangle</title>
			<link href="http://amsykal.github.io/project%20euler/2021/01/02/post007.html"/>
			<updated>2021-01-02T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/project%20euler/2021/01/02/post007</id>
			<content type="html">&lt;h4 id=&quot;problem&quot;&gt;PROBLEM&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=150&quot;&gt;Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a triangular array with integers generated by a pseudorandom generator function, find the sub-triangle with minimum sum.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;STORING THE DATA&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We store the data in a list of lists, say t.&lt;/p&gt;

&lt;p&gt;First row of the list corresponding to index 0 has 1 element.&lt;/p&gt;

&lt;p&gt;The second row has 2 elements and so on.&lt;/p&gt;

&lt;p&gt;i.e t[0] has 1 element, t[1] has 2 , t[2] has 3 and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FINDING THE MINIMUM SUM SUB-TRIANGLE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The idea is to consider every entry (r,c) in tr as the apex of a triangle. Consider every possible sub triangle with this apex and then compute the sum.&lt;/p&gt;

&lt;p&gt;Minimum among all such combinations is the answer.&lt;/p&gt;

&lt;p&gt;Given that there are n rows with i+1 columns for i’th row and (n-r) possible depths for each apex, this algorithm runs in $O(n^3)$ time.It is not very computationally efficient and takes slightly under a minute to run in Python. One step to save some computational time is to precalculate running sums for each row.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In essence,&lt;/p&gt;

&lt;p&gt;For an apex at r,c and for depth n&lt;/p&gt;

&lt;p&gt;$t(r,c,n) = t(r,c,n-1) + \sum_{i=c}^{c+n-1}tr[r+1,i]$&lt;/p&gt;

&lt;p&gt;Where t(r,c,n) is sum of all entries in triangle with apex at r,c and depth n and tr is the triangle.&lt;/p&gt;

&lt;p&gt;The sum $\sum_{i=c}^{c+n-1}tr[r+1,i]$ can be computed by maintaining a 2d list that keeps track of the running sum for each row.&lt;/p&gt;

&lt;p&gt;Below is a partial Python snippet to solve this problem.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ns = number of rows in the triangle
# trsum stores the running sum for each row
# for eg
# trsum[2][3] gives the running sum of elements in row 2 from column 0 to 3

# initalize minimum
ans = 10**10

# for every element in r,c and depth n ,compute sum
for r in range(ns-1):
    for c in range(r+1):
        b = 0
        for n in range(1,ns-r+1):
            if c &amp;gt; 0:
                b += trsum[r+n-1][c+n-1]-trsum[r+n-1][c-1]
            else:
                b += trsum[r+n-1][c+n-1]
            if b &amp;lt; ans:
                ans = b

print(ans)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
		</entry>
	
		<entry>
			<title>Art with Code: Henon Map</title>
			<link href="http://amsykal.github.io/art%20with%20code/2021/01/01/post006.html"/>
			<updated>2021-01-01T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2021/01/01/post006</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;James Gleick, Chaos: Making a New Science: “But unpredictability was not the reason physicists and mathematicians began taking pendulums seriously again in the sixties and seventies. Unpredictability was only the attention-grabber. Those studying chaotic dynamics discovered that the disorderly behavior of simple systems acted as a creative process. It generated complexity: richly organized patterns, sometimes stable and sometimes unstable, sometimes finite and sometimes infinite, but always with the fascination of living things. That was why scientists played with toys.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/006a.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006h.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006k.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006l.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/006m.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//http://www.complexification.net/gallery/machines/henonPhase/
//http://paulbourke.net/fractals/henonphase/
//https://mathworld.wolfram.com/HenonMap.html
// henon phase is a strange attractor (chaos theory)

// number of iterations
let c = 1000;
// each angle gives a different image
let angle;
// array to store points in the final image
let henons = [];
// color palette
let colors = [];

// some values of 'angle' and corresponding scaling factor that give good images
//0.9342725906771222, 400
//5.391262433494741, 400
//2.7919038736981934, 200
// 1.6, 250
//3.703635470629848, 250
//1.401833965519098, 250
//0.4791091265567063
//3.5617524930438464, 200
//1.2898632053310408, 260
//3.191261030344313, 200
//5.200390764686796, 400
//3.713825392598408, 260
//4.817617182430413, 400
//-10,200

// function to get points on the image
function makeHenons(){
  henons.length = 0;
  henons = [];
  for (let k = 0; k &amp;lt; c; k++){
    henon = new PointObj();
    henons.push(henon);
  };
}


function setup()
{
  createCanvas(800,800);
  angle = 4.817617182430413;
  // using different palettes for different sketches
  colors = [color(86, 163, 166),color(72, 69, 56),color(02, 212, 157),
            color(212, 234, 200),color(192, 216, 224)];
  //colors = [color(243, 198, 119),color(123, 30, 122),
  //          color(179, 63, 98),color(249, 86, 79)];
   //colors = [color( 217, 229, 214),color(0, 167, 225),color(237, 222, 164),
  //           color(247, 160, 114),color(255, 155, 66)];
  makeHenons();
  // change background according to palette chosen
  background(250);
}

function draw()
{
  // for every point on the henon[] display it and update
  // to new location based on henon phase equation
  push();
  translate(0.5*width,0.5*height)
  for (let k = 0; k &amp;lt; henons.length; k++){
    henons[k].show();
    henons[k].update();
  }

  pop();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class PointObj{
  constructor(){
    // get a random point in a grid (-1 to 1 along both x and y)
    this.x = random(-1,1);
    this.y = random(-1,1);
    this.k = 0;
    this.X = 0;
    this.Y = 0;
    // scaling factor
    this.f  = 400;
    // give the point a random color
    this.cl = random(colors);
  }

  show(cx,cy){
    // set color,alpha and display point , many points so low alpha
    let cl = this.cl;
    cl.setAlpha(20);
    stroke(cl);
    fill(cl);
    ellipse(this.X,this.Y,1,1);

  }

  // get new location of point based on phase equation
  update(){
    this.k = pow(this.y,1) - pow(this.x,2);
    this.y = (this.x * sin(angle)) + (this.k * cos(angle));
    this.x = (this.x * cos(angle)) - (this.k * sin(angle));
    // scale it
    this.X = this.f*this.x;
    this.Y = this.f*this.y;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;Henon Map is a Strange Attractor.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Attractor&quot;&gt;Wiki on Strange Attractor&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In the mathematical field of dynamical systems, an attractor is a set of numerical values toward which a system tends to evolve, for a wide variety of starting conditions of the system. System values that get close enough to the attractor values remain close even if slightly disturbed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://around.com/chaos-2/&quot;&gt;James Gleick’s book on Chaos&lt;/a&gt; offers a lovely and insightful introduction to Strange Attractors while Steven Strogatz’s book on &lt;a href=&quot;http://www.stevenstrogatz.com/books/nonlinear-dynamics-and-chaos-with-applications-to-physics-biology-chemistry-and-engineering&quot;&gt;Non Linear Dynamics and Chaos&lt;/a&gt; is a great book for a deeper dive.&lt;/p&gt;

&lt;p&gt;The equations used in this series of sketches are&lt;/p&gt;

&lt;p&gt;$x_{n+1} = x_ncosα - (y_n-x_n^2)sinα$&lt;br /&gt;
$y_{n+1} = x_nsinα + (y_n-x_n^2)cosα$&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;references&quot;&gt;REFERENCES&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.complexification.net/gallery/machines/henonPhase/&quot;&gt;Jared Tarbell&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://paulbourke.net/fractals/henonphase/&quot;&gt;Paul Bourke&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mathworld.wolfram.com/HenonMap.html&quot;&gt;MathWorld&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://around.com/chaos-2/&quot;&gt;James Gleick’s book on Chaos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.stevenstrogatz.com/books/nonlinear-dynamics-and-chaos-with-applications-to-physics-biology-chemistry-and-engineering&quot;&gt;Non Linear Dynamics and Chaos by Steven Strogatz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ycJEoqmQvwg&amp;amp;list=PLbN57C5Zdl6j_qJA-pARJnKsmROzPnO9V&quot;&gt;Steven Strogatz Lectures on Non Linear Dynamics&lt;/a&gt;&lt;/p&gt;
</content>
		</entry>
	
		<entry>
			<title>Kadane's Algorithm to Solve the Maximum Sum Subarray Problem</title>
			<link href="http://amsykal.github.io/project%20euler/2020/12/31/post005.html"/>
			<updated>2020-12-31T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/project%20euler/2020/12/31/post005</id>
			<content type="html">&lt;h4 id=&quot;problem&quot;&gt;PROBLEM&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=149&quot;&gt;Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a matrix with entries generated by a pseudorandom generator function, find the subarray made of contiguous entries with  maximum sum along any direction.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;One way to solve this problem is to make 1D arrays out of each horizontal row, vertical column, left diagonal elements and right diagonal elements.&lt;/p&gt;

&lt;p&gt;Then for each of these arrays we find the largest subarray with maximal sum. And finally the maximum among these gives the solution.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;STEP 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This step takes a matrix and generates all possible 1D arrays along the row, column and diagonals.&lt;/p&gt;

&lt;p&gt;Below is a partial python snippet to do this.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def f(g):
	gt = list(zip(*g))
	for i in range(SIZE):
			# left to right top half
			d1= []
			# left to right bottom half
			d2 = []
			# right to left top half
			d3 = []
			# right to left bottom half
			d4 = []
			# row
			d5 = g[i]
			# column
			d6 = gt[i]

			for x in range(0,SIZE-i):
				d1.append(g[x][x+i])
				d2.append(g[x+i][x])
				d3.append(g[x][SIZE-x-i-1])
				d4.append(g[x+i][SIZE-x-1])


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Consider the 4 by 4 2d array(list) g below along with row and column numbers.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;r/c&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;−2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;−6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;−1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;−4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;d5 gives us the rows like [-2,5,3,2], [9,-6,5,1] etc&lt;/p&gt;

&lt;p&gt;d6 gives us the columns like [-2,9,3,-1], [5,-6,2,8] etc&lt;/p&gt;

&lt;p&gt;d1 gives the top half of left to right diagonal like [2], [3,1], [5,5,3]&lt;/p&gt;

&lt;p&gt;d2 gives the bottom half of left to right diagonal like [-1], [3,8], [9,2,-4]&lt;/p&gt;

&lt;p&gt;d3 gives the top half of right to left diagonal like [-2], [5,9], [3,-6, 3]&lt;/p&gt;

&lt;p&gt;d4 gives the bottom half of right to left diagonal like [8], [3,-4], [1,7,8]&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;STEP 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The largest subarray sum problem can be stated formally as follows&lt;/p&gt;

&lt;p&gt;Given an array of integers , $A = [a_0,a_1,….a_{n-1}]$ , find a subarray $A[a_l,….a_r]$ such that $\sum_{i=l}^{r} A[i]$ is maximum&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The maximum sum subarray in A = [-2, 4, 2, -3, 1] is a = [4,2] with sum = 6&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;index&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;elements&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;One way to solve this problem is through brute force. Find every possible subarray and the corresponding sum. Find the maximum among these.&lt;/p&gt;

&lt;p&gt;We will have 15 possible subarrays for this problem listed as below.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;start index&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As we can see, starting from index 0 we have 5 possible subarrays, from index 1 there are 4 possible subarrays and so on.&lt;/p&gt;

&lt;p&gt;For an array of length n, there are n*(n+1)/2 possibilities.&lt;/p&gt;

&lt;p&gt;So the brute force solution can be solved in $O(n^2)$ time.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_subarray_problem&quot;&gt;Jay Kadane&lt;/a&gt; proposed an algorithm to solve the problem in $O(n)$ time.&lt;/p&gt;

&lt;p&gt;Going back to the example, Kadane’s algorithm uses the idea of a local and global maximum.&lt;/p&gt;

&lt;p&gt;Local maximum is the maximum for all subarrays formed with element at index i as the last element.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;start index&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;elements&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If we list all subarrays with index 2 as the last element, we get&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;sum&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So the local maximum for index 2 is 6 corresponding to subarray [4,2]&lt;/p&gt;

&lt;p&gt;Below is the table for local maximums for all indices&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;ending index&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;local max&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A look at the table above tells us 6 is the global maximum and the corresponding subarray [4,2] is the longest subarray.&lt;/p&gt;

&lt;p&gt;The way Kadane’s algorithm implemented in Python is as below.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def kadane(x):
    max_local = x[0]
    max_global = x[0]
    for i in range(1,len(x)):
        max_local = max(x[i],max_local+x[i])
        if max_local &amp;gt; max_global:
            max_global = max_local
    return max_global
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;EXAMPLE 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Consider another example for a code walkthrough.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;index&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;elements&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;max_local = x[0] = 3
max_global = x[0] = 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ITERATIONS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[1],max_local+x[1]) = max(-1,2) = 2&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[2],max_local+x[2]) = max(5,7) = 7&lt;/p&gt;

&lt;p&gt;max_local &amp;gt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 7&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[3],max_local+x[3]) = max(9,16) = 16&lt;/p&gt;

&lt;p&gt;max_local &amp;gt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 16&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[4],max_local+x[4]) = max(-7,9) = 9&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 16&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[5],max_local+x[5]) = max(2,11) = 11&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 16&lt;/p&gt;

&lt;p&gt;This gives a global maximum of 16 corresponding to the subarray 3,-1,5,9&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;EXAMPLE 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = x[0] = 3
max_global = x[0] = 3&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;index&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;3&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;4&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;elements&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-6&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;ITERATIONS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[1],max_local+x[1]) = max(-4,-1) = -1&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[2],max_local+x[2]) = max(1,0) = 1&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 3&lt;/strong&gt;
max_local = max(x[3],max_local+x[3]) = max(5,6) = 6
max_local &amp;gt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 6&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[4],max_local+x[4]) = max(-6,0) = 0&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 6&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;i = 5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;max_local = max(x[5],max_local+x[5]) = max(2,2) = 2&lt;/p&gt;

&lt;p&gt;max_local &amp;lt; max_global&lt;/p&gt;

&lt;p&gt;So max_global = 6&lt;/p&gt;

&lt;p&gt;This gives a global maximum of 6 corresponding to the subarray [1,5]&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;STEP 3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;All that’s left to do is to run the 1D arrays obtained from STEP 1 and run the Kadane’s algorithm on each of them and get the maximum sum for each list. The maximum of these maximums gives the final solution.&lt;/p&gt;

&lt;hr /&gt;
</content>
		</entry>
	
		<entry>
			<title>Divisibility Patterns in Pascal's Triangle</title>
			<link href="http://amsykal.github.io/project%20euler/2020/12/23/post004.html"/>
			<updated>2020-12-23T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/project%20euler/2020/12/23/post004</id>
			<content type="html">&lt;h4 id=&quot;problem&quot;&gt;PROBLEM&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://projecteuler.net/problem=148&quot;&gt;Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Explore divisibility patterns in  Pascal’s Triangle and find the total number of entries in n rows that are not divisible by a prime p.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Pascal’s Triangle&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Given the row number n, we can compute the entries in the row of Pascal’s triangle as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\binom{n}{0},\binom{n}{1},\binom{n}{2},...\binom{n}{n}&lt;/script&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Sierpiński Triangle&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now let’s take the entries in the Pascal’s triangle and replace them with mod 2 values.The figure below shows the first 8 rows of the mod 2 version on left and original version on the right&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e002.png&quot; width=&quot;350&quot; height=&quot;250&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A close look at the mod 2 triangle reveals a Sierpinski Fractal.&lt;/p&gt;

&lt;p&gt;Here is one way to build the Sierpinski mod 2 triangle without using the Pascal’s triangle.&lt;/p&gt;

&lt;p&gt;We take the first triangle of 2 rows and make 2 copies of it below, one on left and one on the right. There is one gap left which we fill with 0. Repeat this procedure again by taking the triangle which now contains 4 rows , make a copy on left and right and fill the gaps with zeroes. We now have a triangle of 8 rows. Proceeding this way we get a Sierpiński triangle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e003.png&quot; width=&quot;350&quot; height=&quot;250&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see , number of rows follows the geometric progression of 2, 4, 8 etc.&lt;/p&gt;

&lt;p&gt;How do we know that this in fact is the Pascal’s mod 2 triangle ? In other words how do we know repeating the top triangle , in the left and right, and filling the gaps (the middle triangle) with zeroes gives us the mod 2 triangle ?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Lucas Theorem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The argument to prove that this indeed is the case, uses Lucas theorem.&lt;/p&gt;

&lt;p&gt;A brief detour to take a look at &lt;a href=&quot;https://brilliant.org/wiki/lucas-theorem/&quot;&gt;Lucas’s theorem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For non-negative integers m and n and a prime p&lt;/p&gt;

&lt;p&gt;$\binom{m}{n} ≡\prod_{i=0}^{k}\binom{m_i}{n_i}(mod \; \;p)$&lt;/p&gt;

&lt;p&gt;Where,&lt;/p&gt;

&lt;p&gt;$m = m_{k}m_{k-1}…m_2m_1m_0$
$n = n_{k}n_{k-1}…n_2n_1n_0$&lt;/p&gt;

&lt;p&gt;are base p representations of m and n&lt;/p&gt;

&lt;p&gt;Consider an example with m = 5 , n = 2, p = 2.&lt;/p&gt;

&lt;p&gt;$5_{10} = 101_2$&lt;/p&gt;

&lt;p&gt;$2_{10} = 010_2$&lt;/p&gt;

&lt;p&gt;$\binom{5}{2} ≡\prod_{i=0}^{3}\binom{m_i}{n_i}(mod \; \;2)$&lt;/p&gt;

&lt;p&gt;$\binom{5}{2} ≡\binom{1}{0}\binom{0}{1}\binom{1}{0}(mod \; \;2) = 0(mod \; \;2)$&lt;/p&gt;

&lt;p&gt;Note that $\binom{r}{c} = 0$ when r &amp;lt; c&lt;/p&gt;

&lt;p&gt;We can verify this is true since $\binom{5}{2} = 10 ≡ 0 (mod \; \;2)$&lt;/p&gt;

&lt;p&gt;Consider yet another example with m = 7, n = 3 and p = 2.&lt;/p&gt;

&lt;p&gt;$7_{10} = 111_2$&lt;/p&gt;

&lt;p&gt;$3_{10} = 011_2$&lt;/p&gt;

&lt;p&gt;$\binom{7}{3} ≡\prod_{i=0}^{3}\binom{m_i}{n_i}(mod \; \;2)$&lt;/p&gt;

&lt;p&gt;$\binom{7}{3} ≡\binom{1}{0}\binom{1}{1}\binom{0}{0}(mod \; \;2) = 1(mod \; \;2)$&lt;/p&gt;

&lt;p&gt;Again we can verify $\binom{7}{3} = 35 ≡ 1 (mod \; \;2)$&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Back to the original question of why the mod 2 Pascal triangle ends up in a Sierpinski triangle.&lt;/p&gt;

&lt;p&gt;Following is the outline of one proof as laid out &lt;a href=&quot;http://larryriddle.agnesscott.org/ifs/siertri/Pascalmath.htm&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Say $P_n$ is the nth triangle.  $P_n$ has $2^n$ rows.&lt;/p&gt;

&lt;p&gt;For a given row r, the entries of the original Pascal triangle (without taking mod 2) are given by $\binom{r}{0},\binom{r}{1},…\binom{r}{r}$&lt;/p&gt;

&lt;p&gt;In general an entry is given by $\binom{r}{c}$ where c = 0,1,…r.&lt;/p&gt;

&lt;p&gt;Since the number of rows equals $2^n$, both r and c are less than $2^n$. Note that counting of rows starts at 0.&lt;/p&gt;

&lt;p&gt;So for n = 0 , $P_0 = 2^0 = 1$ row.&lt;/p&gt;

&lt;p&gt;For n = 1, $P_1 = 2^1 = 2$ rows.&lt;/p&gt;

&lt;p&gt;For n = 2, $P_2 = 2^2 = 4$ rows.&lt;/p&gt;

&lt;p&gt;etc&lt;/p&gt;

&lt;p&gt;Representing r and c in base 2 we have,&lt;/p&gt;

&lt;p&gt;$r = r_{n-1}r_{n-2}…r_2r_1r_0$&lt;/p&gt;

&lt;p&gt;$c = c_{n-1}c_{n-2}…c_2c_1c_0$&lt;/p&gt;

&lt;p&gt;Note that the last row of every  $P_n$  (mod 2 version of the triangle) has $2^n$ entries all of which are 1.&lt;/p&gt;

&lt;p&gt;For instance the last row of $P_3$ has 8 entries and is 11111111.&lt;/p&gt;

&lt;p&gt;Now consider an entry in r,c (row number r and column number c ) in the triangle $P_n$. The corresponding entry in lower left triangle for $P_{n+1}$ is given by $2^n+r, c$ and the lower right triangle is given by $2^n+r,2^n+c$. This is easy to see as the last row of $P_n$ contains $2^n$ entries.&lt;/p&gt;

&lt;p&gt;Example: Consider $P_2$ with r = 2 and c = 0.The corresponding lower triangle entry for $P_3$ is $r = 2^2 + 2, c = 0$ i.e 6,0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e004.png&quot; width=&quot;350&quot; height=&quot;250&quot; /&gt;&lt;/p&gt;

&lt;p&gt;More general representation as clearly illustrated in  &lt;a href=&quot;http://larryriddle.agnesscott.org/ifs/siertri/Pascalmath.htm&quot;&gt;this page&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e005.png&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The aim now is to show that the entries in lower left and lower right triangles of $P_{n+1}$ are equivalent to the entry in $P_n$&lt;/p&gt;

&lt;p&gt;Consider the left triangle entry $2^n+r, c$ in $P_{n+1}$&lt;/p&gt;

&lt;p&gt;We can write $2^n + r$  as $1r_{n-1}r_{n-2}…r_2r_1r_0$ in base 2&lt;/p&gt;

&lt;p&gt;Where r = $r_{n-1}r_{n-2}…r_2r_1r_0$&lt;/p&gt;

&lt;p&gt;From Lucas’s theorem ,&lt;/p&gt;

&lt;p&gt;$\binom{2^n + r}{c}(mod \; \;2) = \binom{1r_{n-1}r_{n-2}…r_2r_1r_0}
{0c_{n-1}c_{n-2}…c_2c_1c_0}(mod \; \;2) = \binom{1}{0}\binom{r_{n-1}}{c_{n-1}}\binom{r_{n-2}}{c_{n-2}}…\binom{r_{0}}{c_{0}}(mod \; \;2) = \binom{r_{n-1}}{c_{n-1}}\binom{r_{n-2}}{c_{n-2}}…\binom{r_{0}}{c_{0}}(mod \; \;2 = \binom{r}{c}(mod \; \;2)$&lt;/p&gt;

&lt;p&gt;Consider the right triangle entry $2^n+r, 2^n + c$ in $P_{n+1}$&lt;/p&gt;

&lt;p&gt;$\binom{2^n+r}{2^n+c}(mod \; \;2) = \binom{1r_{n-1}r_{n-2}…r_2r_1r_0}
{1c_{n-1}c_{n-2}…c_2c_1c_0}(mod \; \;2) = \binom{1}{1}\binom{r_{n-1}}{c_{n-1}}\binom{r_{n-2}}{c_{n-2}}…\binom{r_{0}}{c_{0}}(mod \; \;2) = \binom{r_{n-1}}{c_{n-1}}\binom{r_{n-2}}{c_{n-2}}…\binom{r_{0}}{c_{0}}(mod \; \;2 = \binom{r}{c}(mod \; \;2)$&lt;/p&gt;

&lt;p&gt;We are now left with the middle triangle entries and need to show that these are all 0.&lt;/p&gt;

&lt;p&gt;Consider row 8.
Going from column 1 to column 7 , the original elements in the pascal triangle are given by&lt;/p&gt;

&lt;p&gt;$\binom{8}{1},  \binom{8}{2},…\binom{8}{7}$&lt;/p&gt;

&lt;p&gt;Recall&lt;/p&gt;

&lt;p&gt;$\binom{r}{c} = \binom{r-1}{c} + \binom{r-1}{c-1}$&lt;/p&gt;

&lt;p&gt;i.e each element in current row and column is the sum of adjacent numbers in previous row
As we can see in the case of all numbers in row 8, from column 1 to column 7, the adjacent numbers in previous row are all 1 mod 2 .&lt;/p&gt;

&lt;p&gt;Adding two 1 mod 2 numbers gives us 0 mod 2. So the 7 entries in row 8 are mod 0.&lt;/p&gt;

&lt;p&gt;Proceeding to row 9, we will have six 0 mod 2 numbers from col 2 to col 7. (0 mod 2 + 0 mod 2 = 0 mod 2)&lt;/p&gt;

&lt;p&gt;If we go on this way , we will eventually reach row 14 with just one 0 mod 2 number in column 7.&lt;/p&gt;

&lt;p&gt;Note that the next row is row 15. This is $2^4-1$ i.e the last row of $P_4$ and all entries are 1 mod 2.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;All of the above can be repeated for a mod 3 triangle. The pattern will repeat every $3^n$ rows.&lt;/p&gt;

&lt;p&gt;Below are first 27 rows of mod 3 triangle.&lt;/p&gt;

&lt;p&gt;As we can observe the pattern is repeated after 3 rows and again after 9 rows.&lt;/p&gt;

&lt;p&gt;Notice in particular row 8 and row 26. We see that these rows have alternating 1s and 2s. Also the row that immediately follow i.e row 9 and 27 have 1s at the extremes and all 0s between. This is exactly similar to how the mod 2 triangle works. We can construct mod 5 or mod 7 triangles and see that they all result in the familiar Sierpiński Triangle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e006.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python Snippet Used to Generate the Image Above&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# n = number of rows
# p - which mod p ?

n, p = 82, 3
r = [[0]*n for i in range(n)]
r[0][0] = 1
for i in range(1,n):
   r[i][0] = 1
   r[i][n-1] = 0
   for j in range(1,i):
       r[i][j] = (r[i-1][j-1]+r[i-1][j])%p
   rs = [str(k)+'|' for k in r[i]]
   rs = ''.join(rs[:i])
   print(' '*(n-i) + '|' + rs)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Coming now to the question of how many digits in one row of Pascal’s triangle is not divisible by some prime p&lt;/p&gt;

&lt;p&gt;As we know from Lucas theorem is $\binom{r}{c}$ is divisible by p iff at least one of the base-p digits of c is greater than the corresponding base-p digit of r.  Equivalently $\binom{r}{c}$ is not divisible by p if all of the digits in c is less than or equal to corresponding digit in r.&lt;/p&gt;

&lt;p&gt;Consider row 5 of the mod 2 triangle i.e r = 5, p = 2&lt;/p&gt;

&lt;p&gt;$(5)_{10} = (101)_2$&lt;/p&gt;

&lt;p&gt;c can take on the values from 0 to 5&lt;/p&gt;

&lt;p&gt;In base 2 , the numbers 0 to 5 are&lt;/p&gt;

&lt;p&gt;000 001 010 011 100 101&lt;/p&gt;

&lt;p&gt;As we can see only 010 and 011 have a digit greater than corresponding digit in 101.
And the remaining 4 have all digits less than or equal to corresponding digit in 101.&lt;/p&gt;

&lt;p&gt;We can compute this as follows,
Looking at r = 101, the number of ways in which each digit of c can be lesser than or equal to corresponding digit in r is given as below&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;r&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;number of ways&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So total number of c we can build such that each digit of c can be lesser than or equal to corresponding digit in r is 2x1x2 = 4&lt;/p&gt;

&lt;p&gt;Consider another example, this time considering a mod 3 triangle.&lt;/p&gt;

&lt;p&gt;r = 21&lt;/p&gt;

&lt;p&gt;$21_{10} = 210_3$&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;r&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;2&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;number of ways&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;When $r_i = 2$ the corresponding $c_i$ can be 0,1,2 and therefore 3 ways.&lt;/p&gt;

&lt;p&gt;This gives a total of 3x2x1 = 6 entries in row 21 which are not divisible by 3. This is indeed the case by looking at mod 3 triangle.&lt;/p&gt;

&lt;p&gt;A mod 7 example&lt;/p&gt;

&lt;p&gt;r = 41&lt;/p&gt;

&lt;p&gt;$41_{10} = 56_7$&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;r&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;5&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;6&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;number of ways&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This gives a total of 6x7 = 42 entries in row 41 which are not divisible by 7. This can be verified by looking at mod 7 triangle below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/e007.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In fact row 41 has 42 entries none of which are divisible by 7.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Tying It All Up&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At this point we know&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;How to compute total number of entries in a row r that are not divisible by p.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mod p triangles are Sierpiński triangles and so are recursive in nature.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can use these 2 facts to solve Problem 148 which asks us to compute the number of entries which are not divisible by 7 in the first one billion (109) rows of Pascal’s triangle.&lt;/p&gt;

&lt;p&gt;Looking at a few examples.&lt;/p&gt;

&lt;p&gt;p = 3,&lt;/p&gt;

&lt;p&gt;Listing down the first 27 rows in base 3 we have&lt;/p&gt;

&lt;p&gt;0
1
2
10
11
12
20
21
22
100
101
102
110
111
120
121
122
200
201
202
210
211
212
220
221
222&lt;/p&gt;

&lt;p&gt;For each row we know we can compute the total number of entries not divisible by 3.&lt;/p&gt;

&lt;p&gt;If we do this for first 3 rows we get&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;r&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;number of ways&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Summing up these entries (for first 3 rows) we have&lt;/p&gt;

&lt;p&gt;$1+2+3 = 3\times4/2 = 6$&lt;/p&gt;

&lt;p&gt;Moving on to the next rows from 4 to 9&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;r&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;number of ways&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2x1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;11&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2x2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;12&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2x3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;20&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3x1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;21&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3x2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;22&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3x3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Summing up these entries (for the first 9 rows) we have&lt;/p&gt;

&lt;p&gt;$1\times(1+2+3) + 2\times(1+2+3) + 3\times(1+2+3)$
$= (1+2+3)\times(1+2+3) = (3\times4/2)\times(3\times4/2)$
$=6\times6= 36$&lt;/p&gt;

&lt;p&gt;Moving on further from row 10 to 27 , we can see the pattern and conclude we will have&lt;/p&gt;

&lt;p&gt;$1\times36 + 2\times36 + 3\times36$
$=(1+2+3)\times36$
$=6\times36$
$=216$&lt;/p&gt;

&lt;p&gt;At this point we have&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;rows&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;no of entries not divisible by 3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;36&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;27&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;216&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To generalise given $3^k$ rows, we have $T(3)^k$ entries.&lt;/p&gt;

&lt;p&gt;Where T(3) is the triangular number given by 3(3+1)/2&lt;/p&gt;

&lt;p&gt;As presented &lt;a href=&quot;https://kuanwh.com/pascal-divisibility&quot;&gt;here&lt;/a&gt; ,&lt;/p&gt;

&lt;p&gt;Let G(n) = number of entries not divisible by p for first n rows
g(n) = number of entries not divisible by p for nth row&lt;/p&gt;

&lt;p&gt;For any prime p&lt;/p&gt;

&lt;p&gt;$G(p^i - 1) = (T(p))^i$&lt;/p&gt;

&lt;p&gt;We can also conclude&lt;/p&gt;

&lt;p&gt;$G(a_ip^i−1) = T(a_i)\times(T(p))^i$&lt;/p&gt;

&lt;p&gt;Since $a_ip^i−1 = a_i000…0 - 1$&lt;/p&gt;

&lt;p&gt;For a more general case, we then have the following recursive function&lt;/p&gt;

&lt;p&gt;n = $a_ia_{i-1}…a_2a_1a_0$&lt;/p&gt;

&lt;p&gt;$G(a_ia_{i-1}…a_2a_1a_0)$&lt;/p&gt;

&lt;p&gt;$= G(a_i000…0-1) + g(a_i000…0)+g(a_ia_{i-1}…0)+…g(a_ia_{i-1}…a_2a_1a_0)$&lt;/p&gt;

&lt;p&gt;$= T(a_i)\times(T(p))^i + (a_i+1)G(a_{i-1}000…0-1)$&lt;/p&gt;

&lt;p&gt;Consider n = 25 and p = 3 to illustrate how this works&lt;/p&gt;

&lt;p&gt;$25_{10} = 221_3$&lt;/p&gt;

&lt;p&gt;Writing all numbers in base 3&lt;/p&gt;

&lt;p&gt;$G(221) = G(200-1) + g(200)+g(201)+g(202)+…g(221)$&lt;/p&gt;

&lt;p&gt;$G(200-1) = T(2)\times T(3)^2 = 3\times36 = 108$&lt;/p&gt;

&lt;p&gt;$g(200)+g(201)+g(202)+…g(221)$&lt;/p&gt;

&lt;p&gt;$=(2+1)\times G(21)$&lt;/p&gt;

&lt;p&gt;$G(21) = G(20-1) + g(20) + g(21)$&lt;/p&gt;

&lt;p&gt;$G(20-1) = T(2)\times T(3)^1 = 3\times6 = 18$&lt;/p&gt;

&lt;p&gt;$g(20) + g(21)$&lt;/p&gt;

&lt;p&gt;$=(2+1)\times G(1) = 3$&lt;/p&gt;

&lt;p&gt;Plugging in all the values&lt;/p&gt;

&lt;p&gt;$G(221) = 108 + 3\times (18 + 3) = 171$&lt;/p&gt;

&lt;p&gt;So for n = 25, there are 171 numbers which are not divisible by 3 in the Pascal’s triangle.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The general code in Python&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# convert n to number in base b
def baseconvert(n,b):
   ans = ''
   while n &amp;gt; 0:
       ans += str(n%b)
       n = n//b
   return ans[::-1]

# triangular number
def T(k):
   return k*(k+1)//2

# recursive function G
def G(n):
   if len(n) == 1:
       return T(int(n))

   d = int(n[0])
   return (T(d))*tp**(len(n) - 1) + (d + 1) * G(n[1:])

# an example case with p = 7, n = 100
p = 7
tp = p*(p+1)//2
print(G(baseconvert(100,7)))

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;references&quot;&gt;REFERENCES&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://cjordan.github.io/2013/12/29/solving-project-euler-148/&quot;&gt;C Jordan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kuanwh.com/pascal-divisibility&quot;&gt;Divisibility Patterns in Pascal’s Triangle&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brilliant.org/wiki/lucas-theorem/&quot;&gt;Lucas Theorem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://akira08280.com/euler148&quot;&gt;Akira&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://johncarlosbaez.wordpress.com/2019/02/05/fermat-primes-and-pascals-triangle/&quot;&gt;Sierpinski Triangle mod 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://larryriddle.agnesscott.org/ifs/siertri/Pascalmath.htm&quot;&gt;Sierpinski Triangle mod 2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mathlesstraveled.com/2012/10/20/visualizing-pascals-triangle-remainders/&quot;&gt;Visualising Mod Triangles&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
</content>
		</entry>
	
		<entry>
			<title>Art with Code: Mystery Curves II</title>
			<link href="http://amsykal.github.io/art%20with%20code/2020/12/17/post003.html"/>
			<updated>2020-12-17T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2020/12/17/post003</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;Everything we care about lies somewhere in the middle, where pattern and randomness interlace.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;James Gleick&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/003j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003h.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003e.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/003a.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// mystery curves
// concentric curves of increasing radius in a grid
// takes the following parametric form
// x = cos(p*a) + cos(m*a)/2 + sin(n*a)/3;
// y = sin(p*a) + sin(m*a)/2 + cos(n*a)/3;
// where different values of p,m,n give different curves
// in this series we will randomize p,m,n  - no intentional symmetry
// see that resulting curves are more like scribbles

// colors to plot curve - prettying up things a bit
let colors;

function setup(){
  createCanvas(600,600);
  background(250);
  colors = [color(243, 198, 119),color(123, 30, 122),
            color(179, 63, 98),color(249, 86, 79)];
}

function draw(){
  noLoop();
  // make a grid to plot multiple curves in one canvas
  makeGrid();
}

function makeGrid(){
  // change s to different sizes for different cell sizes
  // this series has used s = 60,100,150,200,300,600
  let s = 600;
  let rows = height/s;
  let cols = width/s;
  strokeWeight(2);
  // iterate over each cell
  for (let x = 0; x &amp;lt; rows +1; x+=1){
    for (let y = 0; y &amp;lt; cols+1; y+=1){
      push();
      // changing origin to center of current cell
      translate(s*x+s/2,s*y+s/2);
      render(s);
      pop();
    }
  }
}
function render(s){
  // set maximum size of curve such that it fits in neatly within the cell
  let c = s/4 ;
  // randomize p,m,n
  p = random(10);
  m = random(20);
  n = random(20);
  // plot the curve
  // plotting cocentric curves of increasing radius for a nice looking sketch
  for(let r = 10; r &amp;lt; c; r+=10){
    // set up colors,alpha etc
    let cl = random(colors);
    cl.setAlpha(150);
    fill(cl);
    stroke(0,150);
    // start plotting
    beginShape();
    for(let a = 0; a &amp;lt; 2*PI; a+= PI/1000){
      // parametric equation of the curve
      let x = cos(p*a) + cos(m*a)/2 + sin(n*a)/3;
      let y = sin(p*a) + sin(m*a)/2 + cos(n*a)/3;
      vertex(r*x,r*y);
    }
    endShape(CLOSE);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;This is again a series based on the same f defined in &lt;a href=&quot;https://amsykal.github.io/github%20pages/2020/12/14/post002.html&quot;&gt;previous post&lt;/a&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large f(t)= e^{it} + \frac{1}{2}e^{imt} + \frac{i}{3}e^{-int}&lt;/script&gt;

&lt;p&gt;However here the choice of m and n has been randomized. So symmetry is no longer achieved. The result is a series of curves which look more like scribbles.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mathlesstraveled.com/2015/06/04/random-cyclic-curves-5/&quot;&gt;Math Less Travelled&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quantamagazine.org/solution-creating-art-with-mathematics-20151030/&quot;&gt;Quanta Magazine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cut-the-knot.org/arithmetic/algebra/FiveFoldGraph.shtml&quot;&gt;Cut the Knot&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Art with Code: Mystery Curves I</title>
			<link href="http://amsykal.github.io/art%20with%20code/2020/12/14/post002.html"/>
			<updated>2020-12-14T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/art%20with%20code/2020/12/14/post002</id>
			<content type="html">&lt;blockquote&gt;
  &lt;p&gt;The most beautiful experience we can have is the mysterious. It is the fundamental emotion that stands at the cradle of true art and true science.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Albert Einstein&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/001f.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001g.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001h.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001i.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001j.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001a.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001b.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001c.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001d.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/images/001e.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THIS SERIES OF SKETCHES&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// mystery curves
// concentric curves of increasing radius in a grid
// takes the following parametric form
// x = cos(p*a) + cos(m*a)/2 + sin(n*a)/3;
// y = sin(p*a) + sin(m*a)/2 + cos(n*a)/3;
// where different values of p,m,n give different curves
// only select combination of values give symmetrical values
// in the next series we will randomize p,m,n and
// see that resulting curves are more like scribbles

// colors to plot curve - prettying up things a bit
let colors;

function setup(){
  createCanvas(600,600);
  background(250);
  colors = [color(243, 198, 119),color(123, 30, 122),
            color(179, 63, 98),color(249, 86, 79)];
}

function draw(){
  noLoop();
  // make a grid to plot multiple curves in one canvas
  makeGrid();
}

function makeGrid(){
  // change s to different sizes for different cell sizes
  // this series has used s = 100,150,200,300,600
  let s = 600;
  let rows = height/s;
  let cols = width/s;
  strokeWeight(2);
  // iterate over each cell
  for (let x = 0; x &amp;lt; rows +1; x+=1){
    for (let y = 0; y &amp;lt; cols+1; y+=1){
      push();
      // changing origin to center of current cell
      translate(s*x+s/2,s*y+s/2);
      render(s);
      pop();
    }
  }
}
function render(s){
  // set maximum size of curve such that it fits in neatly within the cell
  let c = s/4 ;
  // some combinaitons of (p,m,n) which gives neat symmetric curves
  amn = [[1,7,11],[1,6,14],[1,5,11],[1,5,15],[1,8,13],[1,8,20],[1,9,15],
          [1,10,17],[10,10,13]];
  // pick one of the above to plot in the current cell
  q = random(amn);
  p = q[0];
  m = q[1];
  n = q[2];
  // plot the curve
  // plotting cocentric curves of increasing radius for a nice looking sketch
  for(let r = 10; r &amp;lt; c; r+=10){
    // set up colors,alpha etc
    let cl = random(colors);
    cl.setAlpha(150);
    fill(cl);
    stroke(0,150);
    // start plotting
    beginShape();
    for(let a = 0; a &amp;lt; 2*PI; a+= PI/1000){
      // parametric equation of the curve
      let x = cos(p*a) + cos(m*a)/2 + sin(n*a)/3;
      let y = sin(p*a) + sin(m*a)/2 + cos(n*a)/3;
      vertex(r*x,r*y);
    }
    endShape(CLOSE);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;Consider a function f:ℝ→ℂ defined as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large f(t)= e^{it} + \frac{1}{2}e^{imt} + \frac{i}{3}e^{-int}&lt;/script&gt;

&lt;p&gt;The condition for k fold symmetry for f(t) is given as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large f(t + \frac{2\pi}{k}) = e^{i\frac{2\pi}{k}}f(t)&lt;/script&gt;

&lt;p&gt;Solving for m and n in terms of k&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large f(t + \frac{2\pi}{k})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large = e^{i(t+\frac{2\pi}{k})} + \frac{1}{2}e^{im(t+\frac{2\pi}{k})} + \frac{i}{3}e^{-in(t+\frac{2\pi}{k})}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large = e^{i\frac{2\pi}{k}}e^{it} + \frac{1}{2}e^{im\frac{2\pi}{k}}e^{imt} + \frac{i}{3}e^{-in\frac{2\pi}{k}}e^{-int}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large = e^{i\frac{2\pi}{k}}(e^{it}+\frac{1}{2}e^{imt}e^{i(m-1)\frac{2\pi}{k}} + \frac{i}{3}e^{-int}e^{-i(n+1)\frac{2\pi}{k}})&lt;/script&gt;

&lt;p&gt;In order that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large f(t + \frac{2\pi}{k}) = e^{i\frac{2\pi}{k}}f(t)&lt;/script&gt;

&lt;p&gt;We must have k dividing both m-1 and n+1&lt;/p&gt;

&lt;p&gt;If k = 5 , 5 must divide m-1 and n+1&lt;/p&gt;

&lt;p&gt;One possible solution, which has been implemented in the code above is m = 6 and n = 14 giving m-1 = 5 and n+1 = 15.&lt;/p&gt;

&lt;p&gt;m = 8 and n = 13 gives us m-1 = 7 and n+1 = 14 leading to a seven fold symmetry.&lt;/p&gt;

&lt;p&gt;So on and so forth.&lt;/p&gt;

&lt;p&gt;As lucidly explained in &lt;a href=&quot;https://mathlesstraveled.com/2015/06/05/mystery-curve-animated/&quot;&gt;Math Less Travelled&lt;/a&gt;, we can think of the function f&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\large f(t)= e^{it} + \frac{1}{2}e^{imt} + \frac{i}{3}e^{-int}&lt;/script&gt;

&lt;p&gt;in terms of motions around a circle (epicycles). The first term corresponds to a circle of radius unit 1 rotating at a certain speed (red circle below). The second circle (yellow circle) corresponds to a circle of half the radius, rotating 6 times faster than the first, with it’s centre tracing the first circle.The third term corresponds to a circle (white circle) with (1/3)rd the radius of the first circle, moving at a speed 14 times faster,phased out by a quarter rotation.The centre of the third circle traces a path around the second circle.&lt;/p&gt;

&lt;p&gt;The illustration below shows how this works as you see the point at the edge of the 3rd circle (white) traces the function describing the mystery curve(blue) at the end of one full cycle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/002.gif&quot; width=&quot;400&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;CODE FOR THE ABOVE ANIMATION&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// mystery curves
// expressed as a sum of motions in circles

// colors to plot curve - prettying up things a bit
let colors;
let s,c
// number of frames - helps with looping
let numFrames = 300;
// set frame rate
let fps = 10;
// the canvas capturer instance
let capturer = new CCapture({ format: 'png', framerate: fps });

function setup(){
  createCanvas(600,600);
  background(250);
  colors = [color(208, 0, 0),color(255, 186, 8),
            color(221, 225, 230),color(63, 136, 197)];
  s = 600;
  frameRate(fps);
  // start the recording for animation
  capturer.start();

}

function draw(){
  // once we have looped around a curve stop recording and looping
  if (frameCount &amp;gt;= numFrames){
    noLoop();
    capturer.stop();
    capturer.save();
    return;
  }
  // push origin to center
  push();
  translate(s/2,s/2);
  render(s)
  pop();
  // capture this frame
  capturer.capture(document.getElementById('defaultCanvas0'));
}


function render(s){

  // reset background
  background(0);

  // update angle
  let a = 2*PI*frameCount/numFrames;

  // get coordinates for all circles and lines
  let x = c*cos(a);
  let y = -c*sin(a);
  let x1 = c/2*cos(6*a);
  let y1 = -c/2*sin(6*a);
  let x2 = c/3*sin(14*a);
  let y2=  -c/3*cos(14*a);

  // circle 1
  noFill();
  strokeWeight(2);
  cl = colors[0];
  cl.setAlpha(200);
  stroke(cl);
  circle(0,0,2*c,2*c);
  line(0,0,x,y);

  // circle 2
  cl = colors[1];
  cl.setAlpha(200);
  stroke(cl);
  circle(x,y,c,c);
  line(x,y,x+x1,y+y1);

  // circle 3
  cl = colors[2];
  cl.setAlpha(200);
  stroke(cl);
  circle(x+x1,y+y1,(2/3)*c,(2/3)*c);
  line(x+x1,y+y1,x+x1+x2,y+y1+y2);

  // curve - we plot full curve every frame as a reference to
  // see how the circles trace the curve
  cl = colors[3];
  cl.setAlpha(200);
  stroke(cl);
  beginShape();
  for(let a1 = 0; a1 &amp;lt; 2*PI; a1+= PI/1000){
    // parametric equation of the curve
    let x = cos(a1) + cos(6*a1)/2 + sin(14*a1)/3;
    let y = sin(a1) + sin(6*a1)/2 + cos(14*a1)/3;
    vertex(c*x,-c*y);
  }
  endShape(CLOSE);

  // to show the point follwing motions in circles tracing the curve
  fill(colors[0]);
  ellipse(x+x1+x2,y+y1+y2,12,12);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;REFERENCE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mathlesstraveled.com/2015/06/04/random-cyclic-curves-5/&quot;&gt;Math Less Travelled&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.quantamagazine.org/solution-creating-art-with-mathematics-20151030/&quot;&gt;Quanta Magazine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cut-the-knot.org/arithmetic/algebra/FiveFoldGraph.shtml&quot;&gt;Cut the Knot&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

</content>
		</entry>
	
		<entry>
			<title>Building your Github Pages Site</title>
			<link href="http://amsykal.github.io/github%20pages/2019/12/17/post001.html"/>
			<updated>2019-12-17T00:00:00+05:30</updated>
			<id>http://amsykal.github.io/github%20pages/2019/12/17/post001</id>
			<content type="html">&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.github.com/en/articles/setting-up-your-github-pages-site-locally-with-jekyll&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://programminghistorian.org/en/lessons/building-static-sites-with-jekyll-github-pages&quot;&gt;Programming Historian&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://jekyllrb.com/docs/step-by-step/01-setup/&quot;&gt;Jekyll Tutorial&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://codinfox.github.io/dev/2015/03/06/use-tags-and-categories-in-your-jekyll-based-github-pages/&quot;&gt;Coding Fox’s clever solution to Adding Categories and Tags&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
		</entry>
	

</feed>
